"use strict";(self.webpackChunkwire_docs=self.webpackChunkwire_docs||[]).push([[1489],{42492:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>r,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>c,toc:()=>d});var s=o(74848),t=o(28453);const i={title:"Storage and Read Modes"},a=void 0,c={id:"api-reference/tooling/nodeop/concepts/storage-and-read-modes",title:"Storage and Read Modes",description:"The Wire platform stores blockchain information in various data structures at various stages of a transaction's lifecycle. Some of these are described below. The producing node is the nodeop instance run by the block producer who is currently creating blocks for the blockchain (which changes every 6 seconds, producing 12 blocks in sequence before switching to another producer).",source:"@site/docs/api-reference/tooling/nodeop/concepts/storage-and-read-modes.md",sourceDirName:"api-reference/tooling/nodeop/concepts",slug:"/api-reference/tooling/nodeop/concepts/storage-and-read-modes",permalink:"/docs/api-reference/tooling/nodeop/concepts/storage-and-read-modes",draft:!1,unlisted:!1,editUrl:"https://github.com/Wire-Network/wire-docs/docs/api-reference/tooling/nodeop/concepts/storage-and-read-modes.md",tags:[],version:"current",frontMatter:{title:"Storage and Read Modes"},sidebar:"apiReferenceSidebar",previous:{title:"Context-Free Data",permalink:"/docs/api-reference/tooling/nodeop/concepts/context-free-data"},next:{title:"blockvault-client-plugin",permalink:"/docs/api-reference/tooling/nodeop/plugins/blockvault-client-plugin"}},r={},d=[{value:"Blockchain State and Storage",id:"blockchain-state-and-storage",level:2},{value:"Configurable state storage",id:"configurable-state-storage",level:3},{value:"Wire Sysio Interfaces",id:"wire-sysio-interfaces",level:2},{value:"Nodeop RPC API",id:"nodeop-rpc-api",level:3},{value:"Nodeop Read Modes",id:"nodeop-read-modes",level:2},{value:"Speculative Mode",id:"speculative-mode",level:3},{value:"Head Mode",id:"head-mode",level:3},{value:"Read-Only Mode",id:"read-only-mode",level:3},{value:"Irreversible Mode",id:"irreversible-mode",level:3},{value:"How To Specify the Read Mode",id:"how-to-specify-the-read-mode",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["The Wire platform stores blockchain information in various data structures at various stages of a transaction's lifecycle. Some of these are described below. The producing node is the ",(0,s.jsx)(n.code,{children:"nodeop"})," instance run by the block producer who is currently creating blocks for the blockchain (which changes every 6 seconds, producing 12 blocks in sequence before switching to another producer)."]}),"\n",(0,s.jsx)(n.h2,{id:"blockchain-state-and-storage",children:"Blockchain State and Storage"}),"\n",(0,s.jsxs)(n.p,{children:["Every ",(0,s.jsx)(n.code,{children:"nodeop"})," instance creates some internal files to store the blockchain state. These files reside in the ",(0,s.jsx)(n.code,{children:"~/sysio/nodeop/data"})," installation directory and their purpose is described below:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"blocks.log"})," is an append only log of blocks written to disk and contains all the irreversible blocks. These blocks contain final, confirmed transactions."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"reversible_blocks"})," is a memory mapped file and contains blocks that have been written to the blockchain but have not yet become irreversible. These blocks contain valid pushed transactions that still await confirmation to become final via the consensus protocol. The head block is the last block written to the blockchain, stored in ",(0,s.jsx)(n.code,{children:"reversible_blocks"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"chain state"})," or ",(0,s.jsx)(n.code,{children:"chain database"})," is stored either in ",(0,s.jsx)(n.code,{children:"chainbase"})," or in ",(0,s.jsx)(n.code,{children:"rocksdb"}),", dependant on the ",(0,s.jsx)(n.code,{children:"nodeop"})," ",(0,s.jsx)(n.code,{children:"chain_plugin"})," configuration option ",(0,s.jsx)(n.code,{children:"backing-store"}),". It contains the blockchain state associated with each block, including account details, deferred transactions, and data stored using multi index tables in smart contracts. The last 65,536 block IDs are also cached to support Transaction as Proof of Stake (TaPOS). The transaction ID/expiration is also cached until the transaction expires."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"pending block"})," is an in memory block containing transactions as they are processed and pushed into the block; this will/may eventually become the head block. If the ",(0,s.jsx)(n.code,{children:"nodeop"})," instance is the producing node, the pending block is distributed to other ",(0,s.jsx)(n.code,{children:"nodeop"})," instances."]}),"\n",(0,s.jsxs)(n.li,{children:["Outside the ",(0,s.jsx)(n.code,{children:"chain state"}),", block data is cached in RAM until it becomes final/irreversible; specifically the signed block itself. After the last irreversible block (LIB) catches up to the block, that block is then retrieved from the irreversible blocks log."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"configurable-state-storage",children:"Configurable state storage"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Nodeop"})," stores the transaction history and current state. The transaction history is stored in the ",(0,s.jsx)(n.code,{children:"blocks.log"})," file on disk. Current state, which is changed by the execution of transactions, is currently stored using chainbase or RocksDB. Wire Sysio introduces configurable state storage and currently supports these backing stores:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Chainbase"}),"\n",(0,s.jsx)(n.li,{children:"RocksDB"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Chainbase is a proprietary in-memory transactional database, built by Block.one, which uses memory mapped files for persistence."}),"\n",(0,s.jsxs)(n.p,{children:["RocksDB is an open source persistent key value store. Storing state in memory is fast, however limited by the amount of available RAM. RocksDB utilises low latency storage such as flash drives and high-speed disk drives to persist data and memory caches for fast data access. For some deployments, RocksDB may be a better state store. See ",(0,s.jsx)(n.a,{href:"https://rocksdb.org/",children:"the RocksDB website"})," for more information."]}),"\n",(0,s.jsx)(n.h2,{id:"wire-sysio-interfaces",children:"Wire Sysio Interfaces"}),"\n",(0,s.jsxs)(n.p,{children:["Wire provides a set of services and interfaces that enable contract developers to persist state across action, and consequently transaction, boundaries. Contracts may use these services and interfaces for various purposes. For example, ",(0,s.jsx)(n.code,{children:"sysio.token"})," contract keeps balances for all users in the ",(0,s.jsx)(n.code,{children:"chain database"}),". Each instance of ",(0,s.jsx)(n.code,{children:"nodeop"})," maintains the ",(0,s.jsx)(n.code,{children:"chain database"})," in an efficient data store, so contracts can read and write data with ease."]}),"\n",(0,s.jsx)(n.h3,{id:"nodeop-rpc-api",children:"Nodeop RPC API"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"nodeop"})," service provides query access to the chain database via the HTTP ",(0,s.jsx)(n.a,{href:"/docs/api-reference/tooling/nodeop/nodeop-apis",children:"RPC API"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"nodeop-read-modes",children:"Nodeop Read Modes"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"nodeop"}),' service can be run in different "read" modes. These modes control how the node operates and how it processes blocks and transactions:']}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"speculative"}),": this includes the side effects of confirmed and unconfirmed transactions."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"head"}),": this only includes the side effects of confirmed transactions, this mode processes unconfirmed transactions but does not include them."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"read-only"}),": this mode is deprecated. Similar functionality can be achieved by combining options: ",(0,s.jsx)(n.code,{children:"read-mode = head"}),", ",(0,s.jsx)(n.code,{children:"p2p-accept-transactions = false"}),", ",(0,s.jsx)(n.code,{children:"api-accept-transactions = false"}),". When these options are set, the local database will contain state changes made by transactions in the chain up to the head block. Also, transactions received via the P2P network are not relayed and transactions cannot be pushed via the chain API."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"irreversible"}),": this mode also includes confirmed transactions only up to those included in the last irreversible block."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["A transaction is considered confirmed when a ",(0,s.jsx)(n.code,{children:"nodeop"})," instance has received, processed, and written it to a block on the blockchain, i.e. it is in the head block or an earlier block."]}),"\n",(0,s.jsx)(n.h3,{id:"speculative-mode",children:"Speculative Mode"}),"\n",(0,s.jsxs)(n.p,{children:["Clients such as ",(0,s.jsx)(n.code,{children:"clio"})," and the RPC API, will see database state as of the current head block plus changes made by all transactions known to this node but potentially not included in the chain, unconfirmed transactions for example."]}),"\n",(0,s.jsx)(n.p,{children:"Speculative mode is low latency but fragile, there is no guarantee that the transactions reflected in the state will be included in the chain OR that they will reflected in the same order the state implies."}),"\n",(0,s.jsx)(n.p,{children:"This mode features the lowest latency, but is the least consistent."}),"\n",(0,s.jsxs)(n.p,{children:["In speculative mode ",(0,s.jsx)(n.code,{children:"nodeop"})," is able to execute transactions which have TaPoS (Transaction as Proof of Stake) pointing to any valid block in a fork considered to be the best fork by this node."]}),"\n",(0,s.jsx)(n.h3,{id:"head-mode",children:"Head Mode"}),"\n",(0,s.jsxs)(n.p,{children:["Clients such as ",(0,s.jsx)(n.code,{children:"clio"})," and the RPC API will see database state as of the current head block of the chain.  Since current head block is not yet irreversible and short-lived forks are possible, state read in this mode may become inaccurate  if ",(0,s.jsx)(n.code,{children:"nodeop"})," switches to a better fork.  Note that this is also true of speculative mode."]}),"\n",(0,s.jsx)(n.p,{children:"This mode represents a good trade-off between highly consistent views of the data and latency."}),"\n",(0,s.jsxs)(n.p,{children:["In this mode ",(0,s.jsx)(n.code,{children:"nodeop"})," is able to execute transactions which have TaPoS pointing to any valid block in a fork considered to be the best fork by this node."]}),"\n",(0,s.jsx)(n.h3,{id:"read-only-mode",children:"Read-Only Mode"}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsxs)(n.p,{children:["| The explicit ",(0,s.jsx)(n.code,{children:"read-mode = read-only"})," mode is deprecated. Similar functionality can now be achieved in ",(0,s.jsx)(n.code,{children:"head"})," mode by combining options: ",(0,s.jsx)(n.code,{children:"read-mode = head"}),", ",(0,s.jsx)(n.code,{children:"p2p-accept-transactions = false"}),", ",(0,s.jsx)(n.code,{children:"api-accept-transactions = false"}),"."]})}),"\n",(0,s.jsxs)(n.p,{children:["Clients such as ",(0,s.jsx)(n.code,{children:"clio"})," and the RPC API will see database state as of the current head block of the chain. It ",(0,s.jsx)(n.strong,{children:"will not"})," include changes made by transactions known to this node but not included in the chain, such as unconfirmed transactions."]}),"\n",(0,s.jsx)(n.h3,{id:"irreversible-mode",children:"Irreversible Mode"}),"\n",(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.code,{children:"nodeop"})," is configured to be in irreversible read mode, it will still track the most up-to-date blocks in the fork database, but the state will lag behind the current best head block, sometimes referred to as the fork DB head, to always reflect the state of the last irreversible block."]}),"\n",(0,s.jsxs)(n.p,{children:["Clients such as ",(0,s.jsx)(n.code,{children:"clio"})," and the RPC API will see database state as of the current head block of the chain. It ",(0,s.jsx)(n.strong,{children:"will not"})," include changes made by transactions known to this node but not included in the chain, such as unconfirmed transactions."]}),"\n",(0,s.jsx)(n.h2,{id:"how-to-specify-the-read-mode",children:"How To Specify the Read Mode"}),"\n",(0,s.jsxs)(n.p,{children:["The mode in which ",(0,s.jsx)(n.code,{children:"nodeop"})," is run can be specified using the ",(0,s.jsx)(n.code,{children:"--read-mode"})," option from the ",(0,s.jsx)(n.code,{children:"sysio::chain_plugin"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},28453:(e,n,o)=>{o.d(n,{R:()=>a,x:()=>c});var s=o(96540);const t={},i=s.createContext(t);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);