"use strict";(self.webpackChunkwire_docs=self.webpackChunkwire_docs||[]).push([[8718],{52198:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>t,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>l,toc:()=>o});var i=s(74848),r=s(28453);const c={title:"Wallet Specification"},a=void 0,l={id:"api-reference/tooling/kiod/wallet-specification",title:"Wallet Specification",description:"Wallet Import Format (WIF)",source:"@site/docs/api-reference/tooling/kiod/wallet-specification.md",sourceDirName:"api-reference/tooling/kiod",slug:"/api-reference/tooling/kiod/wallet-specification",permalink:"/docs/api-reference/tooling/kiod/wallet-specification",draft:!1,unlisted:!1,editUrl:"https://github.com/Wire-Network/wire-docs/edit/master/docs/api-reference/tooling/kiod/wallet-specification.md",tags:[],version:"current",frontMatter:{title:"Wallet Specification"},sidebar:"apiReferenceSidebar",previous:{title:"wallet_plugin",permalink:"/docs/api-reference/tooling/kiod/plugins/wallet-plugin"},next:{title:"Kiod Troubleshooting",permalink:"/docs/api-reference/tooling/kiod/troubleshooting"}},t={},o=[{value:"Wallet Import Format (WIF)",id:"wallet-import-format-wif",level:2},{value:"Private key to WIF",id:"private-key-to-wif",level:2},{value:"WIF to private key (checksum checking)",id:"wif-to-private-key-checksum-checking",level:2},{value:"Base58check",id:"base58check",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"wallet-import-format-wif",children:"Wallet Import Format (WIF)"}),"\n",(0,i.jsxs)(n.p,{children:["Wallet Import Format is an encoding for a private EDSA key.  Wire uses the same version, checksum, and encoding scheme as the Bitcoin WIF addresses and should be compatible with existing libraries [1]. Check ",(0,i.jsx)(n.a,{href:"https://en.bitcoin.it/wiki/Wallet_import_format",children:"Bitcoin WIF"})," for more information."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example of a WIF Private Key:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"5HpHagT65TZzG1PH3CSu63k8DbpvD8s5ip4nEB3kEsreAbuatmU\n"})}),"\n",(0,i.jsx)(n.p,{children:"This encoding is good for:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Copy and Pasting private keys (ensures the entire key is copied)"}),"\n",(0,i.jsx)(n.li,{children:"Including keys in text or user editable file formats"}),"\n",(0,i.jsx)(n.li,{children:"Shortening the key-length"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["This encoding is ",(0,i.jsx)(n.strong,{children:"not suitable"})," for:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Writing keys down by hand (even a single upper / lowercase mistake can cause a major problem)"}),"\n",(0,i.jsx)(n.li,{children:"Binary or computer storage where code handles the key and data is already checked"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Considerations"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"If a key could be written down or re-keyed, the BIP39 Mnemonic Code standard is a better option to use."}),"\n",(0,i.jsx)(n.li,{children:'It is a good idea to always label a WIF key using the word "Private" or "Private Key".'}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"private-key-to-wif",children:"Private key to WIF"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"A fake private key of all zeros is used.  This is 32 bytes long (shown here as hex)."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-console",children:"0000000000000000000000000000000000000000000000000000000000000000\n"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Add a 0x80 byte in front.  This byte represents the Bitcoin mainnet.  EOS uses the same version byte.  When encoded the version byte helps to identify this as a private key.  Unlike Bitcoin, EOS always uses compressed public keys (derived from a private key) and therefore does not suffix the private key with a 0x01 byte."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-console",children:"800000000000000000000000000000000000000000000000000000000000000000\n"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Perform a binary SHA-256 hash on the versioned key."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-console",children:"ce145d282834c009c24410812a60588c1085b63d65a7effc2e0a5e3a2e21b236\n"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Perform a binary SHA-256 hash on result of SHA-256 hash."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-console",children:"0565fba7ebf8143516e0222d7950c28589a34c3ee144c3876ceb01bfb0e9bb70\n"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Take the first 4 bytes of the second SHA-256 hash, this is the checksum."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-console",children:"0565fba7\n"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Add the 4 checksum bytes to the versioned key from step 2."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-console",children:"8000000000000000000000000000000000000000000000000000000000000000000565fba7\n"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"http://npmjs.com/package/bs58",children:"Base58"})," encode the binary data from step 6."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-console",children:"5HpHagT65TZzG1PH3CSu63k8DbpvD8s5ip4nEB3kEsreAbuatmU\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"wif-to-private-key-checksum-checking",children:"WIF to private key (checksum checking)"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Start with the Wallet Import Private Key."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-console",children:"5HpHagT65TZzG1PH3CSu63k8DbpvD8s5ip4nEB3kEsreAbuatmU\n"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"http://npmjs.com/package/bs58",children:"Base58"})," decode the WIF string (shown as HEX here)."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-console",children:"8000000000000000000000000000000000000000000000000000000000000000000565fba7\n"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Slice the decoded WIF into the versioned key and the checksum (last 4 bytes)."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-console",children:"800000000000000000000000000000000000000000000000000000000000000000\n0565fba7\n"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Perform a binary SHA-256 hash on the versioned key."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-console",children:"ce145d282834c009c24410812a60588c1085b63d65a7effc2e0a5e3a2e21b236\n"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Perform a binary SHA-256 hash on result of SHA-256 hash."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-console",children:"0565fba7ebf8143516e0222d7950c28589a34c3ee144c3876ceb01bfb0e9bb70\n"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Take the first 4 bytes of the second SHA-256 hash, this is the checksum."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-console",children:"0565fba7\n"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Make sure the checksum in steps 3 and 6 match."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Slice the versioned private key from step 3 into the version and private key."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-console",children:"80\n0000000000000000000000000000000000000000000000000000000000000000\n"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"If the version is 0x80 then there is no error."}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"base58check",children:(0,i.jsx)(n.a,{href:"https://www.npmjs.com/package/base58check",children:"Base58check"})}),"\n",(0,i.jsx)(n.p,{children:"Base58Check is a JavaScript implementation of this algorithm and may be used to encode and decode EOS WIF private keys."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sh",children:"base58check = require('base58check')\nwif = base58check.encode(privateKey = '00'.repeat(32), version = '80', encoding = 'hex')\nassert.equal('5HpHagT65TZzG1PH3CSu63k8DbpvD8s5ip4nEB3kEsreAbuatmU', wif)\nlet {prefix, data} = base58check.decode(wif)\nassert.equal(prefix.toString('hex'), '80')\nassert.equal(data.toString('hex'), '00'.repeat(32)))\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>l});var i=s(96540);const r={},c=i.createContext(r);function a(e){const n=i.useContext(c);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(c.Provider,{value:n},e.children)}}}]);