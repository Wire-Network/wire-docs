"use strict";(self.webpackChunkwire_docs=self.webpackChunkwire_docs||[]).push([[3943],{99680:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>l});var i=t(74848),a=t(28453);const o={id:"glossary",title:"Glossary",slug:"/introduction/glossary",tags:["glossary","terminology"],description:"Key Terminology"},s=void 0,r={id:"introduction/glossary",title:"Glossary",description:"Key Terminology",source:"@site/docs/introduction/glossary.md",sourceDirName:"introduction",slug:"/introduction/glossary",permalink:"/docs/introduction/glossary",draft:!1,unlisted:!1,editUrl:"https://github.com/Wire-Network/wire-docs/edit/master/docs/introduction/glossary.md",tags:[{inline:!0,label:"glossary",permalink:"/docs/tags/glossary"},{inline:!0,label:"terminology",permalink:"/docs/tags/terminology"}],version:"current",frontMatter:{id:"glossary",title:"Glossary",slug:"/introduction/glossary",tags:["glossary","terminology"],description:"Key Terminology"},sidebar:"contentSidebar",previous:{title:"Interoperability & WNS",permalink:"/docs/introduction/wns-overview"},next:{title:"Getting Started",permalink:"/docs/getting-started/getting-started-intro"}},c={},l=[{value:"Account",id:"account",level:2},{value:"Account Name",id:"account-name",level:2},{value:"Action",id:"action",level:2},{value:"Application Binary Interface",id:"application-binary-interface",level:2},{value:"Authority",id:"authority",level:2},{value:"Bancor Relay",id:"bancor-relay",level:2},{value:"Block",id:"block",level:2},{value:"Block Header",id:"block-header",level:2},{value:"Block Log",id:"block-log",level:2},{value:"Node Operator",id:"node-operator",level:2},{value:"Node Operator Schedule",id:"node-operator-schedule",level:2},{value:"Block-Producing Node",id:"block-producing-node",level:2},{value:"Blockchain Application",id:"blockchain-application",level:2},{value:"Byzantine Fault Tolerance",id:"byzantine-fault-tolerance",level:2},{value:"CPU",id:"cpu",level:2},{value:"Chain State",id:"chain-state",level:2},{value:"clio",id:"clio",level:2},{value:"Confirmed Transaction",id:"confirmed-transaction",level:2},{value:"Core",id:"core",level:2},{value:"Cryptographic Hash",id:"cryptographic-hash",level:2},{value:"Custom Permission",id:"custom-permission",level:2},{value:"Deferred Action",id:"deferred-action",level:2},{value:"Appointed Proof of Stake(APoS)",id:"appointed-proof-of-stakeapos",level:2},{value:"Deserialization",id:"deserialization",level:2},{value:"Digital Signature",id:"digital-signature",level:2},{value:"Dispatcher",id:"dispatcher",level:2},{value:"Dispatcher Hooks",id:"dispatcher-hooks",level:2},{value:"Distributed Ledger Technology",id:"distributed-ledger-technology",level:2},{value:"Wire Types",id:"wire-types",level:2},{value:"Wire CDT",id:"wire-cdt",level:2},{value:"Genesis Block",id:"genesis-block",level:2},{value:"Genesis Node",id:"genesis-node",level:2},{value:"Governance",id:"governance",level:2},{value:"Head Block",id:"head-block",level:2},{value:"Indices",id:"indices",level:2},{value:"Inline Action",id:"inline-action",level:2},{value:"Irreversible Block",id:"irreversible-block",level:2},{value:"Kiod",id:"kiod",level:2},{value:"Merkle Tree",id:"merkle-tree",level:2},{value:"Multi-Index",id:"multi-index",level:2},{value:"Multi Index Table",id:"multi-index-table",level:2},{value:"Multisig",id:"multisig",level:2},{value:"NET",id:"net",level:2},{value:"Nodeop",id:"nodeop",level:2},{value:"Non-Producing Node",id:"non-producing-node",level:2},{value:"Oracle",id:"oracle",level:2},{value:"Packed Transaction",id:"packed-transaction",level:2},{value:"Peer-to-peer",id:"peer-to-peer",level:2},{value:"Pending Block",id:"pending-block",level:2},{value:"Pending Blocks",id:"pending-blocks",level:2},{value:"Permission",id:"permission",level:2},{value:"Permission Threshold",id:"permission-threshold",level:2},{value:"Permission Weight",id:"permission-weight",level:2},{value:"Permission level",id:"permission-level",level:2},{value:"Plugin",id:"plugin",level:2},{value:"Private Key",id:"private-key",level:2},{value:"Private Network",id:"private-network",level:2},{value:"Privileged",id:"privileged",level:2},{value:"Privileged Account",id:"privileged-account",level:2},{value:"Public Key",id:"public-key",level:2},{value:"Public Network",id:"public-network",level:2},{value:"RAM",id:"ram",level:2},{value:"RAM Market",id:"ram-market",level:2},{value:"REX",id:"rex",level:2},{value:"ROA(Resource Owners Association)",id:"roaresource-owners-association",level:2},{value:"Updog \ud83d\udc15",id:"updog-",level:2},{value:"Read Mode",id:"read-mode",level:2},{value:"Retired Action",id:"retired-action",level:2},{value:"Reversible Block",id:"reversible-block",level:2},{value:"Ricardian Contract",id:"ricardian-contract",level:2},{value:"SYS",id:"sys",level:2},{value:"Scope",id:"scope",level:2},{value:"Serialization",id:"serialization",level:2},{value:"Signature",id:"signature",level:2},{value:"Smart Contract",id:"smart-contract",level:2},{value:"Staking",id:"staking",level:2},{value:"Standard Account Name",id:"standard-account-name",level:2},{value:"Standby Pool",id:"standby-pool",level:2},{value:"System",id:"system",level:2},{value:"System Contract",id:"system-contract",level:2},{value:"Tables",id:"tables",level:2},{value:"Test Network",id:"test-network",level:2},{value:"Transaction",id:"transaction",level:2},{value:"Transaction Reciept",id:"transaction-reciept",level:2},{value:"Transaction Trace",id:"transaction-trace",level:2},{value:"Unconfirmed Transaction",id:"unconfirmed-transaction",level:2},{value:"Wait",id:"wait",level:2},{value:"Wallet",id:"wallet",level:2},{value:"Wallet Import Format",id:"wallet-import-format",level:2},{value:"WebAssembly",id:"webassembly",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",hr:"hr",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"account",children:"Account"}),"\n",(0,i.jsx)(n.p,{children:"An account is a unique identifier and a requirement to interact with a Wire blockchain. Unlike most other cryptocurrencies, transfers are sent to a human-readable account name rather than a public key, while keys attributed to the account are used to sign transactions."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"account-name",children:"Account Name"}),"\n",(0,i.jsx)(n.p,{children:"An account name is a human-readable identifier that is stored on the blockchain.  Account names can only contain the characters .abcdefghijklmnopqrstuvwxyz12345. a-z (lowercase), 1-5 and . (period), must start with a letter or a number; cannot start or end with period. It can be 13 characters and one of them has to be a period."}),"\n",(0,i.jsx)(n.p,{children:"The ability to choose a username is granted to T4 tier."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"action",children:"Action"}),"\n",(0,i.jsx)(n.p,{children:"Functionality exposed by a smart contract that is exercised by passing the correct parameters via an approved transaction to Wire network."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"application-binary-interface",children:"Application Binary Interface"}),"\n",(0,i.jsx)(n.p,{children:"A JSON-based description on how to convert user actions between their JSON and binary representations. The ABI may also describe how to convert the database state to/from JSON. Once you have described your contract via an ABI this allows developers and users to interact with your contract seamlessly via JSON."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Abbreviation"}),": ABI"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"authority",children:"Authority"}),"\n",(0,i.jsx)(n.p,{children:"On the Wire platform, the authority relates a public key and the authorization factors for an account and an account permission. The authority is a data structure linking account permissions to keys, thresholds, weights, delegated account permissions, and time waits."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Related"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#permission",children:"Permission"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#account",children:"Account"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#permission-level",children:"Permission Level"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#permission-weight",children:"Permission Weight"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#permission-threshold",children:"Permission Threshold"})}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"bancor-relay",children:"Bancor Relay"}),"\n",(0,i.jsx)(n.p,{children:"Wire adopts a free-market approach to allocating scarce resources such as RAM. The Wire system contract allows users to buy RAM from the system and sell RAM back to the system in exchange for the blockchain's native tokens. This provides liquidity in the RAM market while facilitating price discovery. The less unallocated RAM available to the market maker the higher the market maker prices the remaining RAM. The algorithm used for this market maker is known as a Bancor Relay. A Bancor Relay does not set the price of RAM. It only offers to buy and sell at previously established market rates. Anytime the current market rate is different than the current price offered by the Bancor Relay, traders will buy or sell RAM pushing to closer to the market determined price."}),"\n",(0,i.jsx)(n.h2,{id:"block",children:"Block"}),"\n",(0,i.jsx)(n.p,{children:'A confirmable unit of a blockchain. Each block contains zero or more transactions, as well as a cryptographic connection to all prior blocks. When a block becomes "irreversibly confirmed" it\'s because a supermajority of node operators have agreed that the given block contains the correct transactions. Once a block is irreversibly confirmed, it becomes a permanent part of the immutable blockchain.'}),"\n",(0,i.jsx)(n.h2,{id:"block-header",children:"Block Header"}),"\n",(0,i.jsx)(n.p,{children:"A part of the block which holds metadata related to the block. In an Wire block header this includes things like the transaction Merkle root, the action Merkle root, the producer who produced the block, the block id of the previous block, the block id of the current block, and the block timestamp."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Related"})," ",(0,i.jsx)(n.a,{href:"#merkle-tree",children:"Block Merkle Tree"})]}),"\n",(0,i.jsx)(n.h2,{id:"block-log",children:"Block Log"}),"\n",(0,i.jsx)(n.p,{children:"The block log is an append-only log of blocks written to disk and contains all the irreversible blocks."}),"\n",(0,i.jsx)(n.h2,{id:"node-operator",children:"Node Operator"}),"\n",(0,i.jsx)(n.p,{children:"A Node Operator Producer is an identifiable entity composed of one or more individuals that express interest in participating in running an Wire network. By participating it is meant these entities will provide a full node, gather transactions, verify their validity, add them into blocks, and propose and confirm these blocks. A Node Operator is generally required to have experience with system administration and security as it is expected that their full-node have constant availability."}),"\n",(0,i.jsx)(n.h2,{id:"node-operator-schedule",children:"Node Operator Schedule"}),"\n",(0,i.jsx)(n.p,{children:"The list of block producers who currently have the possibility of being selected to produce the next block. This list changes with every new block."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Related"})," ",(0,i.jsx)(n.a,{href:"#node-operator",children:"Node Operator"})]}),"\n",(0,i.jsx)(n.h2,{id:"block-producing-node",children:"Block-Producing Node"}),"\n",(0,i.jsxs)(n.p,{children:["A full node running ",(0,i.jsx)(n.code,{children:"nodeop"}),' that is actively producing blocks. A producing node, if voted out, will become a producing node on "standby". Standby operators are synced with the nextwork but they will only start producing blocks and earn rewards if they are selected to be part of the 21 Node Operators.']}),"\n",(0,i.jsx)(n.h2,{id:"blockchain-application",children:"Blockchain Application"}),"\n",(0,i.jsx)(n.p,{children:"A blockchain application is a software application that has integrated a blockchain in its architecture as the storage layer for part of, or, all of its data. This includes software applications that do not own their own contract on the blockchain and instead only interact with the system contracts of the blockchain."}),"\n",(0,i.jsx)(n.h2,{id:"byzantine-fault-tolerance",children:"Byzantine Fault Tolerance"}),"\n",(0,i.jsx)(n.p,{children:"In the context of distributed systems, Asyncronous Byzantine Fault Tolerance (aBFT) is the ability of a distributed computer network to function as desired and correctly reach a sufficient consensus despite malicious components (nodes) of the system failing or propagating incorrect information to other peers. In an Wire based blockchain aBFT is achieved using a combination of Appointed Proof of Stake, the last irreversible block, and the fact that a producer cannot sign two blocks with the same block number."}),"\n",(0,i.jsx)(n.h2,{id:"cpu",children:"CPU"}),"\n",(0,i.jsx)(n.p,{children:"CPU is processing power granted to an account by an Wire based blockchain. The amount of CPU an account has is measured in microseconds, and represents the amount of processing time an account has at its disposal when executing its actions."}),"\n",(0,i.jsx)(n.h2,{id:"chain-state",children:"Chain State"}),"\n",(0,i.jsx)(n.p,{children:'The chain state (or "database" as it is often called) is a memory mapped file, which stores the blockchain state of each block (account details, deferred transactions, transactions, data stored using multi index tables in smart contracts, etc.). Once a block becomes irreversible the chain state is no longer cached.'}),"\n",(0,i.jsx)(n.h2,{id:"clio",children:"clio"}),"\n",(0,i.jsx)(n.p,{children:"clio is a command line tool that interfaces with the REST api exposed by nodeop, in other words clio is the command line tool through which you can interface with an Wire based blockchain; clio contains documentation for all of its commands. For a list of all commands known to clio, simply run it with no arguments. clio = command line + eos"}),"\n",(0,i.jsx)(n.h2,{id:"confirmed-transaction",children:"Confirmed Transaction"}),"\n",(0,i.jsx)(n.p,{children:"On completion of the transaction, a transaction receipt is generated. Receiving a transaction hash does not mean that the transaction has been confirmed, it only means that the node accepted it without error, which also means that there is a high probability other producers will accept it. A transaction is considered confirmed when a nodeop instance has received, processed, and written it to a block on the blockchain, i.e. it is in the head block or an earlier block."}),"\n",(0,i.jsx)(n.h2,{id:"core",children:"Core"}),"\n",(0,i.jsx)(n.p,{children:"The core is used to refer to the Wire blockchain native components, e.g. native actions, chain libraries, nodeop daemon, etc. The core is the Wire platform on which Wire based blockchains can be instantiated and tailored by means of deploying smart contracts (including the system smart contracts). Therefore, the system smart contracts are not considered part of the core or native blockchain implementation."}),"\n",(0,i.jsx)(n.h2,{id:"cryptographic-hash",children:"Cryptographic Hash"}),"\n",(0,i.jsx)(n.p,{children:"A cryptographic hash function is a hash function which takes an input (or 'message') and returns a fixed-size alphanumeric string. The alphanumeric string is called the 'hash value', 'message digest', 'digital fingerprint', 'digest' or 'checksum'."}),"\n",(0,i.jsx)(n.h2,{id:"custom-permission",children:"Custom Permission"}),"\n",(0,i.jsx)(n.p,{children:"In addition to the native permissions, owner and active, an account can possess custom named permissions that are available to further extend account management. Custom permissions are incredibly flexible and address numerous possible use cases when implemented. Custom permissions are arbitrary and impotent until they have been linked to an action."}),"\n",(0,i.jsx)(n.h2,{id:"deferred-action",children:"Deferred Action"}),"\n",(0,i.jsx)(n.p,{children:"Deferred actions are actions sent to a peer action that are scheduled to run, at best, at a later time, at a block producer's discretion. There is no guarantee that a deferred action will be executed. From the perspective of the originating action, i.e., the action that creates the deferred action, it can only determine whether the create request was submitted successfully or whether it failed (if it fails, it will fail immediately). Deferred actions carry the authority of the contract that sends them. A deferred action can also be cancelled by another action."}),"\n",(0,i.jsx)(n.h2,{id:"appointed-proof-of-stakeapos",children:"Appointed Proof of Stake(APoS)"}),"\n",(0,i.jsx)(n.p,{children:"Wire Network's consensus algorithm that builds upon a Delegated Proof of Stake, which was originally developed by Daniel Larimer. APoS addresses DPoS consensus challenges by separating roles and responsibilities of Node Owners from Node Operators,"}),"\n",(0,i.jsx)(n.h2,{id:"deserialization",children:"Deserialization"}),"\n",(0,i.jsx)(n.p,{children:"Deserialization is the reverse process of serialization. It turns a stream of bytes into an object in memory. Wire structures are enhanced with two operators which implement the serialization and deserialization of data to and from the database."}),"\n",(0,i.jsx)(n.h2,{id:"digital-signature",children:"Digital Signature"}),"\n",(0,i.jsx)(n.p,{children:"A digital signature is a mathematical scheme for verifying the authenticity of digital messages or documents. A valid digital signature, where the prerequisites are satisfied, gives a recipient very strong reason to believe that the message was created by a known sender (authentication), and that the message was not altered in transit (integrity). Digital signatures are a standard element of most cryptographic protocol suites, and are commonly used for software distribution, financial transactions, contract management software, and in other cases where it is important to detect forgery or tampering."}),"\n",(0,i.jsx)(n.h2,{id:"dispatcher",children:"Dispatcher"}),"\n",(0,i.jsx)(n.p,{children:"Every smart contract must provide an apply action handler. The apply action handler is a function that listens to all incoming actions and performs the desired behavior. In order to respond to a particular action, code is required to identify and respond to specific action requests. apply uses the receiver, code, and action input parameters as filters to map to the desired functions that implement particular actions."}),"\n",(0,i.jsx)(n.h2,{id:"dispatcher-hooks",children:"Dispatcher Hooks"}),"\n",(0,i.jsx)(n.p,{children:'In addition to actions and notification handlers, two "hooks" are available. The pre_dispatch hook will fire when the dispatcher is run and allow the smart contract to do some pre-validation and exit early if need be by returning false. If the function returns true then the dispatcher continues to dispatch the actions or notification handlers. The post_dispatch hook will only fire when the dispatcher has failed to match any notification handlers, this allows the user to do some meaningful last ditch validation.'}),"\n",(0,i.jsx)(n.h2,{id:"distributed-ledger-technology",children:"Distributed Ledger Technology"}),"\n",(0,i.jsx)(n.p,{children:"A consensus of replicated, shared, and synchronized digital data geographically spread across multiple sites, countries, or institutions. DLT is also called a shared ledger."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Abbreviation"})," : DLT"]}),"\n",(0,i.jsx)(n.h2,{id:"wire-types",children:"Wire Types"}),"\n",(0,i.jsxs)(n.p,{children:["Wire source code defines a list of types which ease the developer's work when writing smart contracts, plugins, or when extending the Wire source code. Example types include ",(0,i.jsx)(n.code,{children:"account_name"}),", ",(0,i.jsx)(n.code,{children:"permission_name"}),", ",(0,i.jsx)(n.code,{children:"table_name"}),", ",(0,i.jsx)(n.code,{children:"action_name"}),", ",(0,i.jsx)(n.code,{children:"scope_name"}),", ",(0,i.jsx)(n.code,{children:"weight_type"}),", ",(0,i.jsx)(n.code,{children:"public_key"}),", etc."]}),"\n",(0,i.jsx)(n.h2,{id:"wire-cdt",children:"Wire CDT"}),"\n",(0,i.jsx)(n.p,{children:"The toolchain to build WebAssembly (WASM) and set of tools to facilitate smart contract development for the Wire platform."}),"\n",(0,i.jsx)(n.h2,{id:"genesis-block",children:"Genesis Block"}),"\n",(0,i.jsx)(n.p,{children:"The genesis block is the very first block in the Wire blockchain. The subsequent block added after the genesis block becomes block 1 and continues the sequence. The genesis block lays the foundation for other blocks to be added to form a blockchain."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Related"})," ",(0,i.jsx)(n.a,{href:"#block",children:"Block"})]}),"\n",(0,i.jsx)(n.h2,{id:"genesis-node",children:"Genesis Node"}),"\n",(0,i.jsx)(n.p,{children:"The genesis node is the first node in the blockchain network. The genesis node is used to perform a set of actions such as creating system accounts, initializing system, and token contracts in order to create a fully-functional blockchain with varying capabilities such as governance, resource allocation, and more."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Synonyms"})," Single Producer Node"]}),"\n",(0,i.jsx)(n.h2,{id:"governance",children:"Governance"}),"\n",(0,i.jsx)(n.p,{children:"Blockchain governance is a lot like other kinds of governance, except that it's underpinned by smart contracts and transparent voting on the blockchain. Governance, the mechanism by which collective decisions are made, of a Wire based blockchain is achieved through 21 active Node Operators which are appointed by token holders. The 21 active Node Operators continuously create the blockchain via block creation, secure the blocks by validating them, and reach consensus on the state of the blockchain as a whole. Consensus is reached when 2/3+ active node operators agree on validity of a block , therefore on all transactions contained in it and their order."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Related"})," ",(0,i.jsx)(n.a,{href:"#irreversible-block",children:"Irreversible Block"})]}),"\n",(0,i.jsx)(n.h2,{id:"head-block",children:"Head Block"}),"\n",(0,i.jsxs)(n.p,{children:["The head block is the last block written to the blockchain, stored in ",(0,i.jsx)(n.code,{children:"reversible_blocks"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"indices",children:"Indices"}),"\n",(0,i.jsx)(n.p,{children:"In the context of a multiple index table, an index is a particular ordering of the elements in the table. Multiple index indices allow the same data in one table to be viewed as different data structures by specifying the specific index on the table. Wire multiple index tables allow for up to 16 unique indices."}),"\n",(0,i.jsx)(n.h2,{id:"inline-action",children:"Inline Action"}),"\n",(0,i.jsx)(n.p,{children:"Inline actions request other actions that need to be executed as part of the original calling action. Inline actions operate with the same scopes and authorities of the original transaction, and are guaranteed to execute with the current transaction. These can effectively be thought of as nested transactions within the calling transaction. If any part of the transaction fails, the inline actions will unwind with the rest of the transaction."}),"\n",(0,i.jsx)(n.h2,{id:"irreversible-block",children:"Irreversible Block"}),"\n",(0,i.jsx)(n.p,{children:"Irreversible blocks are blocks that contain confirmed, final transactions. A block is considered irreversible (i.e., immutable) on an Wire-based blockchain when a supermajority, consisting of 2/3rds plus 1 of the currently elected node operators have confirmed the block."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Related"}),": ",(0,i.jsx)(n.a,{href:"#block",children:"Block"})]}),"\n",(0,i.jsx)(n.h2,{id:"kiod",children:"Kiod"}),"\n",(0,i.jsx)(n.p,{children:"kiod is the component that securely stores Wire keys in wallets. kiod = key + eos"}),"\n",(0,i.jsx)(n.h2,{id:"merkle-tree",children:"Merkle Tree"}),"\n",(0,i.jsx)(n.p,{children:"A Merkle tree is a tree in which every leaf node is labelled with the hash of a data block, and every non-leaf node is labelled with the cryptographic hash of the labels of its child nodes. Hash trees allow efficient and secure verification of the contents of large data structures."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Synonyms"})," Hash tree\n",(0,i.jsx)(n.strong,{children:"Related"}),": ",(0,i.jsx)(n.a,{href:"#block-header",children:"Block Header"})]}),"\n",(0,i.jsx)(n.h2,{id:"multi-index",children:"Multi-Index"}),"\n",(0,i.jsxs)(n.p,{children:["Wire wraps the ",(0,i.jsx)(n.a,{href:"https://www.boost.org/doc/libs/1_75_0/libs/multi_index/doc/index.html",children:"boost multi-index C++"})," library to provide in memory data persistence. A subset of the functionality provided by the boost multi- index is provided in the Wire multi-index."]}),"\n",(0,i.jsx)(n.h2,{id:"multi-index-table",children:"Multi Index Table"}),"\n",(0,i.jsx)(n.p,{children:"Multi Index Tables, are a way to cache state and/or data in RAM for fast access. Multi index tables support create, read, update, and delete (CRUD) operations, something which the blockchain doesn't (it only supports create and read). Multi index tables are stored in Wire RAM and each smart contract using a multi index table reserves a partition of the RAM cache. Access to each partition is controlled using the table name, code, and scope, and can have up to 16 indexes or indices defined."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Synonyms"})," Multiple Index Tables"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Related"})," ",(0,i.jsx)(n.a,{href:"#indices",children:"Indices"})]}),"\n",(0,i.jsx)(n.h2,{id:"multisig",children:"Multisig"}),"\n",(0,i.jsx)(n.p,{children:"Multisig is a short term for multiple signatures. It\u2019s used to describe the case in which one requires more than one account's permission to execute a transaction. Wire provides the system account sysio.msig, which can be used to push onto the blockchain the multisig proposals and their corresponding account's permission required to approve the proposal. Multisig, when used properly, increases the security of an account, the security of a smart contract, and it's also the method by which producers are able to affect changes within an Wire blockchain."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Synonyms"})," msig multiple signatures"]}),"\n",(0,i.jsx)(n.h2,{id:"net",children:"NET"}),"\n",(0,i.jsx)(n.p,{children:"NET is required to store transactions on an Wire based blockchain. The amount of NET an account has is measured in bytes, representing the amount of transaction storage an account has at its disposal when creating a new transaction. NET is recalculated after each block is produced, based on the system tokens staked for NET bandwidth by the account. The amount allocated to an account is proportional with the total system tokens staked for NET by all accounts. Do not confuse NET with RAM, although it is also storage space, NET measures the size of the transactions and not contract state."}),"\n",(0,i.jsx)(n.h2,{id:"nodeop",children:"Nodeop"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"nodeop"})," is the core Wire node daemon that can be configured with plugins to run a node. Example uses are block production, dedicated API endpoints, and local development."]}),"\n",(0,i.jsx)(n.h2,{id:"non-producing-node",children:"Non-Producing Node"}),"\n",(0,i.jsx)(n.p,{children:'A full node running nodeop that is only watching and verifying for itself each block, and maintaining its own local full copy of the blockchain. A non-producing node that is in the "standby pool" can, through the process of being voted in, become a Producing Node. A producing node, if voted out, will become a non-producing node. For large Wire changes, non-producing nodes are outside the realm of the "standby pool".'}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Related"})," ",(0,i.jsx)(n.a,{href:"#block-producing-node",children:"Block Producing Node"})]}),"\n",(0,i.jsx)(n.h2,{id:"oracle",children:"Oracle"}),"\n",(0,i.jsx)(n.p,{children:"An oracle, in the context of blockchains and smart contracts, is an agent that finds and verifies real-world occurrences and submits this information to a blockchain to be used by smart contracts."}),"\n",(0,i.jsx)(n.h2,{id:"packed-transaction",children:"Packed Transaction"}),"\n",(0,i.jsx)(n.p,{children:"In order to transfer transaction content between nodes faster and to save storage space when storing transaction content in and Wire based blockchain database, the transactions are 'translated' from json into a packed form which is smaller in size. To get the packed version of a transaction one can use the clio convert command."}),"\n",(0,i.jsx)(n.h2,{id:"peer-to-peer",children:"Peer-to-peer"}),"\n",(0,i.jsx)(n.p,{children:"Peer-to-peer computing or networking is a distributed application architecture that partitions tasks or workloads between peers. If peers are equally privileged, equipotent participants in an application, they are said to form a peer-to-peer network of nodes."}),"\n",(0,i.jsx)(n.h2,{id:"pending-block",children:"Pending Block"}),"\n",(0,i.jsx)(n.p,{children:"The pending block is the block currently being built by each node. Transactions are added to the pending block as they are received and processed. The pending block becomes the head block once it is written to the blockchain. Note that a head block is initially reversible."}),"\n",(0,i.jsx)(n.h2,{id:"pending-blocks",children:"Pending Blocks"}),"\n",(0,i.jsx)(n.p,{children:"The pending block is an in memory block containing transactions as they are processed into a block, this will/may eventually become the head block. If this instance of nodeop is the producing node then the pending block will eventually be distributed to other nodeop instances."}),"\n",(0,i.jsx)(n.h2,{id:"permission",children:"Permission"}),"\n",(0,i.jsx)(n.p,{children:'A weighted security mechanism that determines whether or not a message is properly authorized by evaluating its signature(s) authority. Every account has two default permissions, owner and active, but can also have custom permissions to further secure communications from an account to contracts. Every permission name has a "parent." Parents possess the authority to change any of the permissions settings for any and all of their children.'}),"\n",(0,i.jsx)(n.h2,{id:"permission-threshold",children:"Permission Threshold"}),"\n",(0,i.jsx)(n.p,{children:"The sum of permission weights necessary for a signature to be considered valid."}),"\n",(0,i.jsx)(n.h2,{id:"permission-weight",children:"Permission Weight"}),"\n",(0,i.jsx)(n.p,{children:"A permission weight is a value given to an account for authorization purposes. This is typically used in the context of a mutli-sig to give one or more accounts more control over a multi-sig than others."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Synonyms"})," Authorization"]}),"\n",(0,i.jsx)(n.h2,{id:"permission-level",children:"Permission level"}),"\n",(0,i.jsx)(n.p,{children:'Permissions are arbitrary names used to define the requirements for a transaction sent on behalf of that permission. Permissions can be assigned for authority over specific contract actions by "linking authorization" or linkauth. Every account has two native named permissions, owner and active. Every permission name has a "parent." Parents possess the authority to change any of the permission settings for any and all of their children. In addition to the native permissions, an account can possess custom named permissions that are available to further extend account management. Custom permissions are incredibly flexible and address numerous possible use cases when implemented correctly. Given this context permission level is used to identify a specific permission, either active, or owner, or a custom one.'}),"\n",(0,i.jsx)(n.h2,{id:"plugin",children:"Plugin"}),"\n",(0,i.jsx)(n.p,{children:"nodeop plugins are software components that implement features that complement the native Wire blockchain basic implementation. They can be enabled or disabled through the nodeop configuration file or specifying them in the command line that launches the nodeop daemon."}),"\n",(0,i.jsx)(n.h2,{id:"private-key",children:"Private Key"}),"\n",(0,i.jsx)(n.p,{children:"A private key is a secret key used to sign transactions. In Wire, a private key's authority is determined by it's mapping to an Wire account name."}),"\n",(0,i.jsx)(n.h2,{id:"private-network",children:"Private Network"}),"\n",(0,i.jsx)(n.p,{children:"A private network is a production network, or a test network, to which access is private, that is, the API endpoints, and node operators connectivity URLs and IPs are private. Access to a private network is done via invitation, or, upon request to join, is granted by the owners of the private network."}),"\n",(0,i.jsx)(n.h2,{id:"privileged",children:"Privileged"}),"\n",(0,i.jsxs)(n.p,{children:["Privileged accounts are accounts which can execute transactions while skipping the standard authorization check. To ensure that this is not a security hole, the permission authority over these accounts is granted to the sysio.prods account. An account can be set as privileged by sending the action setpriv to an Wire based blockchain, specifying the account to be set as privileged, and providing the correct permission, or, by using ",(0,i.jsx)(n.code,{children:"clio"})," command line utility."]}),"\n",(0,i.jsx)(n.h2,{id:"privileged-account",children:"Privileged Account"}),"\n",(0,i.jsx)(n.p,{children:"At the genesis of an Wire based blockchain, there is only one account present, Wire which is the main system account."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Related"})," ",(0,i.jsx)(n.a,{href:"#account",children:"Account"})]}),"\n",(0,i.jsx)(n.h2,{id:"public-key",children:"Public Key"}),"\n",(0,i.jsx)(n.p,{children:"A publicly available key that can be authorized to permissions of an account and can be used to identify the origin transaction. A public key can be inferred from a signature."}),"\n",(0,i.jsx)(n.h2,{id:"public-network",children:"Public Network"}),"\n",(0,i.jsx)(n.p,{children:"A public network is a production network instantiated with the Wire platform. For a public network, the tokens have value on public markets, and all of the features required to run and maintain the network, such as consensus and governance, are enabled. To contrast a public network, in a private network typically tokens are not traded on public markets, and there is less emphasis placed on governance."}),"\n",(0,i.jsx)(n.h2,{id:"ram",children:"RAM"}),"\n",(0,i.jsx)(n.p,{children:"RAM is required to store account information such as keys, balances, and contract state on an Wire based blockchain. Because the amount of RAM available to a single computer is limited by Moore\u2019s Law and other technological advances, RAM is fundamentally scarce and must be purchased on a free-market inside an Wire based blockchain."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Related"})," ",(0,i.jsx)(n.a,{href:"#bancor-relay",children:"Bancor Relay"})]}),"\n",(0,i.jsx)(n.h2,{id:"ram-market",children:"RAM Market"}),"\n",(0,i.jsx)(n.p,{children:"In order to persist data on an Wire based blockchain, a user must first purchase RAM. The Wire RAM market uses the Bancor Relay algorithm in a system smart contract to offer to buy and sell RAM from users at previously established market rates."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Related"})," ",(0,i.jsx)(n.a,{href:"#bancor-relay",children:"Bancor Relay"})]}),"\n",(0,i.jsx)(n.h2,{id:"rex",children:"REX"}),"\n",(0,i.jsx)(n.p,{children:"The REX (Resource Exchange) is a CPU and Network resource rental market in which holders of the core token of a blockchain can buy and sell slices of the REX pool in the form of REX tokens. Blockchain users can then rent CPU and Network resources from the REX pool."}),"\n",(0,i.jsx)(n.h2,{id:"roaresource-owners-association",children:"ROA(Resource Owners Association)"}),"\n",(0,i.jsx)(n.p,{children:"A REX extension."}),"\n",(0,i.jsx)(n.h2,{id:"updog-",children:"Updog \ud83d\udc15"}),"\n",(0,i.jsx)(n.p,{children:"The mechanism/process for exchanging data between chains. It is responsible for block production schedule and verification of Node Operators."}),"\n",(0,i.jsx)(n.h2,{id:"read-mode",children:"Read Mode"}),"\n",(0,i.jsx)(n.p,{children:"An Wire based blockchain allows contract developers to persist state across actions, and consequently transaction, boundaries. For example the sample sysio.token contract keeps balances for all users in the database. Each instance of nodeop keeps the database in memory, so contracts can read and write data quickly. However, at any given time there can be multiple correct ways, called modes, to query that data."}),"\n",(0,i.jsx)(n.h2,{id:"retired-action",children:"Retired Action"}),"\n",(0,i.jsx)(n.p,{children:"An action within a validated transaction, that is, an action whose transaction was executed and pushed to a block, but may or may not be final yet."}),"\n",(0,i.jsx)(n.h2,{id:"reversible-block",children:"Reversible Block"}),"\n",(0,i.jsx)(n.p,{children:"Any block on an Wire based blockchain with a block number greater than the last irreversible block. Reversible blocks are blocks that are not currently guaranteed to be on the blockchain."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Related"})," ",(0,i.jsx)(n.a,{href:"#irreversible-block",children:"Irreversible Block"})]}),"\n",(0,i.jsx)(n.h2,{id:"ricardian-contract",children:"Ricardian Contract"}),"\n",(0,i.jsx)(n.p,{children:"In the Wire based blockchain context Ricardian Contract is a digital document that accompanies a smart contract and defines the terms and conditions of an interaction between the smart contract and its users, written in human readable text, which is then cryptographically signed and verified. It is easily readable for both humans and programs, and aids in providing clarity to any situations that may arise in the interactions between smart contract and its users."}),"\n",(0,i.jsx)(n.h2,{id:"sys",children:"SYS"}),"\n",(0,i.jsx)(n.p,{children:"SYS is the blockchain default token name for an Wire based blockchain. Any fork of the Wire open source has the option to rename it to any token name that meets the symbol validation rules."}),"\n",(0,i.jsx)(n.h2,{id:"scope",children:"Scope"}),"\n",(0,i.jsx)(n.p,{children:"Scope is a region of data within a contract. Contracts can only write to regions in their own contracts but they can read from any other contract's regions. Proper scoping allows transactions to run in parallel for the same contract because they do not write to the same regions. Scope is not to be conflated with an account name, but contracts can use the same value for both for convenience."}),"\n",(0,i.jsx)(n.h2,{id:"serialization",children:"Serialization"}),"\n",(0,i.jsx)(n.p,{children:"Serialization is the process of turning an object in memory into a stream of bytes so you can store it on disk or send it over the network."}),"\n",(0,i.jsx)(n.h2,{id:"signature",children:"Signature"}),"\n",(0,i.jsx)(n.p,{children:"A signature is a mathematical scheme for demonstrating the authenticity of digital messages or documents."}),"\n",(0,i.jsx)(n.h2,{id:"smart-contract",children:"Smart Contract"}),"\n",(0,i.jsx)(n.p,{children:"A smart contract is a computer protocol intended to facilitate, verify, or enforce the negotiation or performance of a contract."}),"\n",(0,i.jsx)(n.h2,{id:"staking",children:"Staking"}),"\n",(0,i.jsx)(n.p,{children:"Staking is the act of locking tokens for resources on an Wire network. This includes but is not limited to, CPU time, RAM, and on-chain governance."}),"\n",(0,i.jsx)(n.h2,{id:"standard-account-name",children:"Standard Account Name"}),"\n",(0,i.jsx)(n.p,{children:"Standard account names can only contain the characters .abcdefghijklmnopqrstuvwxyz12345. a-z (lowercase), 1-5 and. (period), must start with a letter and must be 12 characters in length."}),"\n",(0,i.jsx)(n.h2,{id:"standby-pool",children:"Standby Pool"}),"\n",(0,i.jsx)(n.p,{children:"A set of about 100 full nodes that have expressed the desire to be selected as Node Operators, and are capable of doing so on demand. Whenever the chain needs to replace an existing Node Operator with a new one, the new one is drawn from the standby pool."}),"\n",(0,i.jsx)(n.h2,{id:"system",children:"System"}),"\n",(0,i.jsx)(n.p,{children:"Everything that is part of Wire which is not part of core, is referred to as system, e.g. system accounts, privileged accounts, system contracts. From an architectural point of view system components sit on top of the core/native components."}),"\n",(0,i.jsx)(n.h2,{id:"system-contract",children:"System Contract"}),"\n",(0,i.jsxs)(n.p,{children:["The design of the Wire blockchain calls for a number of smart contracts that are run at a ",(0,i.jsx)(n.em,{children:"privileged"})," permission level in order to support functions such as node operator registration, multi-sig, etc. These smart contracts are referred to as the system contracts and are the following, sysio.bios, sysio.system, sysio.token, sysio.msig and sysio.wrap contracts."]}),"\n",(0,i.jsx)(n.h2,{id:"tables",children:"Tables"}),"\n",(0,i.jsx)(n.p,{children:"Tables on an Wire-based blockchain are achieved via Multiple Index Table."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Related"})," ",(0,i.jsx)(n.a,{href:"#multi-index-table",children:"Multiple Index Table"})]}),"\n",(0,i.jsx)(n.h2,{id:"test-network",children:"Test Network"}),"\n",(0,i.jsx)(n.p,{children:"A test network or testnet is an instantiation of the Wire platform that is intended for testing purposes. Generally, the native token has no value and is given away to developers so they can test. Some features of a testnet may be disabled such as consensus and governance."}),"\n",(0,i.jsx)(n.h2,{id:"transaction",children:"Transaction"}),"\n",(0,i.jsx)(n.p,{children:"A complete all-or-nothing change to the Blockchain. A combination of one or more actions. Usually the execution result of a Smart Contract."}),"\n",(0,i.jsx)(n.h2,{id:"transaction-reciept",children:"Transaction Reciept"}),"\n",(0,i.jsxs)(n.p,{children:["On completion of a transaction, a transaction receipt is generated. This receipt takes the form of a hash. Receiving a transaction hash does ",(0,i.jsx)(n.em,{children:"not"})," mean that the transaction has been confirmed, it simply means that the node accepted it without error, which also means that there is a high probability other producers will accept it."]}),"\n",(0,i.jsx)(n.h2,{id:"transaction-trace",children:"Transaction Trace"}),"\n",(0,i.jsx)(n.p,{children:"Transaction trace is a log of all the actions that took place as a result of an initial action (inline actions, deferred actions, context free actions, etc), including the initial action, for all actions that are processed on the blockchain. A transaction trace for one transaction includes among other things, the transaction id, the block id that the transaction is part of, the time when the block was produced, the producer id, the time elapsed to process the transaction, and a list of all actions contained in the transactions."}),"\n",(0,i.jsx)(n.h2,{id:"unconfirmed-transaction",children:"Unconfirmed Transaction"}),"\n",(0,i.jsx)(n.p,{children:"A transaction is considered unconfirmed as long as no nodeop instance has received, processed, and written it to a block on the blockchain, i.e. it is not in the head block or a block earlier than the head block."}),"\n",(0,i.jsx)(n.h2,{id:"wait",children:"Wait"}),"\n",(0,i.jsx)(n.p,{children:"Wait is measured in seconds and it is the time to wait until a delayed transaction is executed. Its value can not be higher than the max_transaction_delay which is set in the global configuration file."}),"\n",(0,i.jsx)(n.h2,{id:"wallet",children:"Wallet"}),"\n",(0,i.jsx)(n.p,{children:"Wallets are clients that store keys that may or may not be associated with the permissions of one or more accounts. Ideally a wallet has a locked (encrypted) and unlocked (decrypted) state that is protected by a high entropy password."}),"\n",(0,i.jsx)(n.h2,{id:"wallet-import-format",children:"Wallet Import Format"}),"\n",(0,i.jsx)(n.p,{children:"An encoding for a private EDSA key. Wire uses the same version, checksum, and encoding scheme as the Bitcoin WIF addresses and should be compatible with existing libraries."}),"\n",(0,i.jsxs)(n.p,{children:["Example of a WIF Private Key: ",(0,i.jsx)(n.code,{children:"5HpHagT65TZzG1PH3CSu63k8DbpvD8s5ip4nEB3kEsreAbuatmU"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Abbreviation"})," : WIF"]}),"\n",(0,i.jsx)(n.h2,{id:"webassembly",children:"WebAssembly"}),"\n",(0,i.jsx)(n.p,{children:"The Wire based blockchains execute user-generated applications and code using WebAssembly. WASM is an emerging web standard with widespread support of Google, Microsoft, Apple, and others. At the moment the most mature toolchain for building applications that compile to WASM is clang/llvm with their C/C++ compiler. For best compatibility, it is recommended that you use the Wire toolchain to generate WASM."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Synonyms"})," Web-Assembly Machine\n",(0,i.jsx)(n.strong,{children:"Abbreviation"})," : Wasm"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var i=t(96540);const a={},o=i.createContext(a);function s(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);