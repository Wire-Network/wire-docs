"use strict";(self.webpackChunkwire_docs=self.webpackChunkwire_docs||[]).push([[1169],{90367:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>c,toc:()=>o});var i=t(74848),s=t(28453);const r={},a=void 0,c={id:"api-reference/wire-cdt/features/native-tester-compilation",title:"native-tester-compilation",description:'As of v1.5.0 native compilation can be performed and a new set of libraries to facilitate native testing and native "scratch pad" compilation. cdt-cc, cdt-cpp and cdt-ld now support building "smart contracts" and unit tests natively for quick tests to help facilitate faster development (note the default implementations of a lot of the Antelope intrinsics (aka host functions) are currently asserts that state they are unavailable, these are user definable.)',source:"@site/docs/api-reference/wire-cdt/features/native-tester-compilation.md",sourceDirName:"api-reference/wire-cdt/features",slug:"/api-reference/wire-cdt/features/native-tester-compilation",permalink:"/wire-docs/docs/api-reference/wire-cdt/features/native-tester-compilation",draft:!1,unlisted:!1,editUrl:"https://github.com/Wire-Network/wire-docs/docs/api-reference/wire-cdt/features/native-tester-compilation.md",tags:[],version:"current",frontMatter:{}},l={},o=[{value:"Getting Started",id:"getting-started",level:2},{value:"Compiling Native Code",id:"compiling-native-code",level:2},{value:"CDT Native Tester API",id:"cdt-native-tester-api",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:['As of v1.5.0 native compilation can be performed and a new set of libraries to facilitate native testing and native "scratch pad" compilation. ',(0,i.jsx)(n.a,{href:"/wire-docs/docs/api-reference/tooling/cdt/cdt-cc",children:(0,i.jsx)(n.code,{children:"cdt-cc"})}),", ",(0,i.jsx)(n.a,{href:"/wire-docs/docs/api-reference/tooling/cdt/cdt-cpp",children:(0,i.jsx)(n.code,{children:"cdt-cpp"})})," and ",(0,i.jsx)(n.a,{href:"/wire-docs/docs/api-reference/tooling/cdt/cdt-ld",children:(0,i.jsx)(n.code,{children:"cdt-ld"})}),' now support building "smart contracts" and unit tests natively for quick tests to help facilitate faster development (note the default implementations of a lot of the Antelope intrinsics (aka host functions) are currently asserts that state they are unavailable, these are user definable.)']}),"\n",(0,i.jsx)(n.h2,{id:"getting-started",children:"Getting Started"}),"\n",(0,i.jsx)(n.p,{children:"Once you have your smart contract written then a test source file can be written."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"hello.hpp"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c++",children:'#include <sysio/sysio.hpp>\n\nusing namespace sysio;\n\nclass [[sysio::contract]] hello : public sysio::contract {\n  public:\n      using contract::contract;\n\n      [[sysio::action]] void hi( name user );\n\n      // accessor for external contracts to easily send inline actions to your contract\n      using hi_action = action_wrapper<"hi"_n, &hello::hi>;\n};\n'})}),"\n",(0,i.jsxs)(n.p,{children:["and then a quick test\n",(0,i.jsx)(n.code,{children:"hello_test.cpp"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c++",children:'#include <sysio/sysio.hpp>\n#include <sysio/tester.hpp>\n\n#include <hello.hpp>\n\nusing namespace sysio;\nusing namespace sysio::native;\n\nSYSIO_TEST_BEGIN(hello_test)\n   // These can be redefined by the user to suit there needs per unit test\n   // the idea is that in a future release there will be a base library that \n   // initializes these to "useable" default implementations and probably \n   // helpers to more easily define read_action_data and action_data_size intrinsics\n   // like these"\n   intrinsics::set_intrinsic<intrinsics::read_action_data>(\n         [](void* m, uint32_t len) {\n            check(len <= sizeof(sysio::name), "failed from read_action_data");\n            *((sysio::name*)m) = "hello"_n;\n            return len; \n         });\n\n   intrinsics::set_intrinsic<intrinsics::action_data_size>(\n         []() {\n            return (uint32_t)sizeof(sysio::name);\n         });\n   \n   intrinsics::set_intrinsic<intrinsics::require_auth>(\n         [](capi_name nm) {\n         });\n\n   \n   // "Name : hello" should be in the print buffer\n   CHECK_PRINT("Name : hello",\n         []() {\n            apply("test"_n.value, "test"_n.value, "hi"_n.value);\n            });\n           \n   // should not assert\n   apply("test"_n.value, "test"_n.value, "check"_n.value);\n   \n   name nm = "null"_n;\n   intrinsics::set_intrinsic<intrinsics::read_action_data>(\n         [&](void* m, uint32_t len) {\n            check(len <= sizeof(sysio::name), "failed from read_action_data");\n            *((sysio::name*)m) = nm;\n            return len; \n         });\n\n   REQUIRE_ASSERT( "check name not equal to `hello`",\n         []() {\n            // should assert\n            apply("test"_n.value, "test"_n.value, "check"_n.value);\n            });\n\nSYSIO_TEST_END\n\n// boilerplate main, this will be generated in a future release\nint main(int argc, char** argv) {\n   silence_output(true);\n   SYSIO_TEST(hello_test);\n   return has_failed();\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Every ",(0,i.jsx)(n.code,{children:"intrinsic"})," that is defined for sysio (prints, require_auth, etc.) is re-definable given the ",(0,i.jsx)(n.code,{children:"intrinsics::set_intrinsics<intrinsics::the_intrinsic_name>()"})," functions.  These take a lambda whose arguments and return type should match that of the intrinsic you are trying to define.  This gives the contract writer the flexibility to modify behavior to suit the unit test being written. A sister function ",(0,i.jsx)(n.code,{children:"intrinsics::get_intrinsics<intrinsics::the_intrinsic_name>()"})," will return the function object that currently defines the behavior for said intrinsic.  This pattern can be used to mock functionality and allow for easier testing of smart contracts.  For more information see, either the ",(0,i.jsx)(n.a,{href:"https://github.com/Wire-Network/cdt/tree/main/examples/hello/tests/",children:"tests"})," directory or ",(0,i.jsx)(n.a,{href:"https://github.com/Wire-Network/cdt/blob/main/examples/hello/tests/hello_test.cpp",children:"hello_test.cpp"})," for working examples."]}),"\n",(0,i.jsx)(n.h2,{id:"compiling-native-code",children:"Compiling Native Code"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Raw ",(0,i.jsx)(n.code,{children:"cdt-cpp"})," to compile the test or program the only addition needed to the command line is to add the flag ",(0,i.jsx)(n.code,{children:"-fnative"})," this will then generate native code instead of ",(0,i.jsx)(n.code,{children:"wasm"})," code."]}),"\n",(0,i.jsxs)(n.li,{children:["Via CMake","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"add_native_library"})," and ",(0,i.jsx)(n.code,{children:"add_native_executable"})," CMake macros have been added (these are a drop in replacement for add_library and add_executable)."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"cdt-native-tester-api",children:"CDT Native Tester API"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["CHECK_ASSERT(...) : This macro will check whether a particular assert has occured and flag the tests as failed but allow the rest of the tests to run.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["This is called either by","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:'CHECK_ASSERT("<assert message>", [](<args>){ whatever_function(<args>); })'})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"CHECK_ASSERT([](std::string msg){ user defined comparison function }, [](<args>){ whatever_function(<args>); })"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["CHECK_PRINT(...) : This macro will check whether the print buffer holds the string that is expected and flag the tests as failed but allow the rest of the test to run.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["This is called either by","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:'CHECK_PRINT("<print message>", [](<args>){ whatever_function(<args>); })'})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"CHECK_PRINT([](std::string print_buffer){ user defined comparison function }, [](<args>){ whatever_function(<args>); })"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"CHECK_EQUAL(X, Y) : This macro will check whether two inputs equal eachother and fail the test but allow the rest of the test to continue."}),"\n",(0,i.jsxs)(n.li,{children:["REQUIRE_ASSERT(...) : This macro will check whether a particular assert has occured and flag the tests as failed and halt the test on failure.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["This is called either by","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:'REQUIRE_ASSERT("<assert message>", [](<args>){ whatever_function(<args>); })'})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"REQUIRE_ASSERT([](std::string msg){ user defined comparison function }, [](<args>){ whatever_function(<args>); })"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["REQUIRE_PRINT(...) : This macro will check whether the print buffer holds the string that is expected and flag the tests as failed and halt the test on failure.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["This is called either by","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:'REQUIRE_PRINT("<print message>", [](<args>){ whatever_function(<args>); })'})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"REQUIRE_PRINT([](std::string print_buffer){ user defined comparison function }, [](<args>){ whatever_function(<args>); })"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["REQUIRE_EQUAL(X, Y) : This macro will check whether two inputs ",(0,i.jsx)(n.code,{children:"X"})," and ",(0,i.jsx)(n.code,{children:"Y"})," equal eachother and fail the test and halt the test on failure."]}),"\n",(0,i.jsxs)(n.li,{children:["SYSIO_TEST_BEGIN(X) : This macro defines the beginning of a unit test and assigns ",(0,i.jsx)(n.code,{children:"X"})," as the symbolic name of that test."]}),"\n",(0,i.jsx)(n.li,{children:"SYSIO_TEST_END : This macro defines the end of a unit test."}),"\n",(0,i.jsxs)(n.li,{children:["SYSIO_TEST(X) : This is used to run a particular named unit test ",(0,i.jsx)(n.code,{children:"X"})," in the main function."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>c});var i=t(96540);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);